ДЗ4 — Максимальний потік (логістика)

Завдання 1. Застосування алгоритму максимального потоку для логістики товарів

1. Які термінали забезпечують найбільший потік товарів?

Згідно з результатами:
Terminal 1: загальний потік = 60
Terminal 2: загальний потік = 55

Висновок:
Найбільший потік товарів забезпечує Terminal 1, оскільки сумарний обсяг переданого товару з нього більший.

2. Які маршрути мають найменшу пропускну здатність і як це впливає?

У мережі найменші пропускні здатності мають, наприклад:
Warehouse 4 → Shop 13 (capacity = 5)

деякі ребра Terminal → Warehouse з capacity 10–15

Вплив:

Такі маршрути швидко насичуються і обмежують можливість збільшення загального потоку, навіть якщо інші частини мережі мають резерв пропускної здатності.

3. Які магазини отримали найменше товарів?

З результатів:

Shop 3, Shop 9, Shop 12, Shop 13, Shop 14 → 0

Пояснення:

Ці магазини не отримали товарів через обмежену пропускну здатність суміжних ребер або відсутність вільного шляху в залишковій мережі.

Чи можна покращити?

Так, шляхом збільшення пропускної здатності ребер, що ведуть до відповідних складів або магазинів.

4. Чи є вузькі місця в мережі?

Так.

Вузькі місця (bottlenecks):
ребра з малими capacity (5–10)
виходи зі складів з обмеженим сумарним потоком
обмеження між терміналами та складами

Висновок:

Усунення вузьких місць (збільшення capacity критичних ребер) дозволить підвищити максимальний потік усієї логістичної мережі.

Чи нормально, що не всі магазини отримали товар?

Так, абсолютно нормально.

Це очікувана властивість задачі максимального потоку, а не помилка:
алгоритм не зобов’язаний постачати всі магазини
він максимізує загальний потік, а не рівномірність розподілу


Завдання 2. Розширення функціоналу префіксного дерева (Trie)

У другій частині домашнього завдання було розширено функціональність префіксного дерева (Trie) для вирішення задач аналізу текстових даних.

Мета завдання
Метою було реалізувати додаткові методи, які дозволяють:
- визначати кількість слів, що закінчуються на заданий суфікс;
- перевіряти наявність слів із заданим префіксом.

Такі операції є типовими для пошукових систем, автодоповнення та обробки природної мови.


Реалізація

Було створено клас `Homework`, який **успадковує базовий клас `Trie`**. Для забезпечення ефективної роботи методів використано додаткові
структури даних:
- словник `_suffix_count` — зберігає кількість слів для кожного суфікса;
- множина `_prefixes` — зберігає всі можливі префікси слів;
- лічильник `_words_total` — загальна кількість доданих слів.

При кожному виклику методу `put()`:
- оновлюються всі префікси слова;
- оновлюються всі можливі суфікси слова;
- дані зберігаються з урахуванням регістру символів.


Опис методів

`count_words_with_suffix(pattern)`

Метод повертає кількість слів, що закінчуються на заданий суфікс `pattern`.

Особливості:
- приймає лише рядкові значення;
- повертає ціле число;
- якщо слів із заданим суфіксом немає — повертає `0`;
- працює за **O(1)** завдяки попередньо побудованому індексу.

`has_prefix(prefix)`

Метод перевіряє, чи існує хоча б одне слово з заданим префіксом `prefix`.

Особливості:
- повертає `True`, якщо префікс знайдено;
- повертає `False`, якщо таких слів немає;
- враховує регістр символів;
- перевірка виконується за **O(1)**.

Обробка помилок
Усі методи перевіряють коректність вхідних даних.
У разі передачі параметрів некоректного типу генерується виняток `TypeError`.

Тестування
Коректність реалізації перевіряється за допомогою набору тестів `assert`,
які перевіряють:
- правильність підрахунку слів за суфіксом;
- правильність визначення наявності префікса;
- поведінку методів за відсутності відповідних слів.

У разі успішного проходження тестів програма виводить повідомлення:

All tests passed ✅

Висновок
Реалізоване розширення Trie-дерева дозволяє ефективно виконувати
операції пошуку за префіксами та суфіксами навіть на великих наборах даних.
Використання допоміжних індексів суттєво підвищує продуктивність
у порівнянні з прямим перебором слів.